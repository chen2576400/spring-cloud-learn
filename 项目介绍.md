zookeeper 是AP(强一致性)
eureka 是CP (高可用性)



2001为eureka客户端支付模块
2002为eureka客户端消费模块（调用支付模块,也可以说2001是2002的服务端）
3000 3001为eureka注册中心集群版本



zookeeper服务器端是网上下载启动的
4001是zookeeper客户端支付模块
4002是zookeeper客户端消费模块（调用支付模块）




5001 采用openfegin




========================================【负载均衡调用服务-Ribbon 】========================================================================
spring-cloud-starter-netflix-eureka-client（已经包含了Ribbon和Loadbalancer）
负载均衡：1：采用Ribbon   用restTemplate调用时候 必须加上@LoadBalanced注解  否则报错（找不到server）
修改Ribbon默认负载均衡（轮询）
新增的修改负载均衡配置类不能放在@ComponentScan扫描的包下，否则所有应用Ribbon的客户端使用而不能达到特殊定制的目的，
不要放在Application启动类同级别或者以下（启动时候虽然@Configuration无法识别因为不受启动类纳入容器，但是在第一次负载均衡时候会被初始化调用）
轮询配置是在调用方的客户端配置（2002调用2001   在2002配置）

【轮询的默认算法原理】
rest接口第几次请求数%服务器集群总数量 =实际服务器调用下标，每次服务器重启时候 rest从1开始
List<ServiceInstance>  instances=discoveryClient.getInstances("注册中心name);
如 AliCloud-provider-payment2001模块放在 2000 和2001 两个端口部署
List[0] instances=127.0.0.1:2000  List[1] instances=127.0.0.1:2001
他们集群总数为2，按照轮询算法原理：
当请求数为1： 1%2=1  对应下标为1，则获取服务器地址端口为 2001
当请求数为2： 2%2=0  对应下标为0，则获取服务器地址端口为 2000
当请求数为3： 3%2=1  对应下标为1，则获取服务器地址端口为 2001
当请求数为4： 4%2=0  对应下标为0，则获取服务器地址端口为 2000



【手写轮询算法】
调用时:将restTemplate的@LoadBalanced注解取消 （只有自定义写的算法才需要注释掉，其余的都要开启）
【修改默认负载均衡】
调用时 启动类加上@RibbonClient(name = "ALICLOUD-PROVIDER-PAYMENT2001",configuration = MySelfRule.class )
restTemplate 调用还是要开启@LoadBalanced    MySelfRule为修改的默认负债均衡实现类这里采用随机
========================================【负载均衡调用服务-Ribbon】========================================================================


